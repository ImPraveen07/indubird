<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>INDU bird</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #000; touch-action: none;
            font-family: 'Arial', sans-serif;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #scoreBoard { 
            position: absolute; top: env(safe-area-inset-top, 20px); right: 20px;
            color: white; font-weight: bold;
            text-shadow: 2px 2px #000; text-align: right; pointer-events: none; z-index: 10;
        }
        #currentScore { font-size: clamp(30px, 8vw, 50px); }
        #topScore { font-size: clamp(16px, 4vw, 22px); color: #FFD700; }
    </style>
</head>
<body>
    <div id="scoreBoard">
        <div id="currentScore">0</div>
        <div id="topScore">Best: 0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('currentScore');
    const topScoreEl = document.getElementById('topScore');

    const pipeImg = new Image(); pipeImg.src = 'pipe.png';
    const bgImg = new Image(); bgImg.src = 'flappybg.jpg';
    const birdImg = new Image(); birdImg.src = 'bird.png';
    const yeetSound = new Audio('yeet.mp3');
    const omgSound = new Audio('omg.mp3');

    let highScore = localStorage.getItem('flappyHighScore') || 0;
    topScoreEl.innerText = "Best: " + highScore;

    let unit, pipeWidth, pipeGap, birdSize, gravity, jumpForce, speed;
    let score = 0;
    let gameActive = false; 
    let isGameOver = false; 
    let bgX = 0; 
    let dizzyAngle = 0;
    let deathTime = 0;

    const bird = { x: 0, y: 0, velocity: 0, rotation: 0, wingTimer: 0, mouthOpen: 0 };
    let pipes = [];

    function initScaling() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        unit = canvas.height / 100; 
        birdSize = unit * 8;
        pipeWidth = unit * 12;
        pipeGap = unit * 28;
        gravity = unit * 0.05;
        jumpForce = unit * -1.1;
        speed = unit * 0.5;
        bird.x = unit * 10;
        if (!gameActive && !isGameOver) bird.y = canvas.height / 2;
    }

    window.addEventListener('resize', initScaling);
    initScaling();

    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy;
        let step = Math.PI / spikes;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;
            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
        ctx.fillStyle = '#FFEB3B'; ctx.fill();
        ctx.strokeStyle = '#F57F17'; ctx.lineWidth = 1; ctx.stroke();
    }

    function handleAction(e) {
        if (e) e.preventDefault();
        if (isGameOver) {
            if (Date.now() - deathTime > 1500) resetGame();
        } else if (gameActive) {
            bird.velocity = jumpForce;
            bird.mouthOpen = 15;
            yeetSound.currentTime = 0; yeetSound.play();
        } else {
            resetGame();
        }
    }

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') handleAction(e); });
    canvas.addEventListener('touchstart', handleAction, { passive: false });
    canvas.addEventListener('mousedown', (e) => { if (e.button === 0) handleAction(e); });

    function resetGame() {
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('flappyHighScore', highScore);
            topScoreEl.innerText = "Best: " + highScore;
        }
        score = 0; scoreEl.innerText = "0";
        bird.y = canvas.height / 2; bird.velocity = 0;
        pipes = []; gameActive = true; isGameOver = false;
    }

    function drawDizzyEffect() {
        dizzyAngle += 0.08; 
        const centerX = bird.x + birdSize / 2;
        const centerY = bird.y - unit * 2;
        const orbitWidth = unit * 6;
        const orbitHeight = unit * 2;
        for (let i = 0; i < 3; i++) {
            const angle = dizzyAngle + (i * Math.PI * 2) / 3;
            const x = centerX + Math.cos(angle) * orbitWidth;
            const y = centerY + Math.sin(angle) * orbitHeight;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(dizzyAngle * 2); 
            drawStar(0, 0, 5, unit * 1.5, unit * 0.7);
            ctx.restore();
        }
    }

    function drawBird() {
        bird.wingTimer += 0.15;
        const flap = isGameOver ? 0 : Math.sin(bird.wingTimer) * (unit * 1.5); 
        bird.rotation = isGameOver ? 0.5 : Math.min(Math.PI / 4, Math.max(-Math.PI / 4, bird.velocity * 0.08));
        ctx.save();
        ctx.translate(bird.x + birdSize / 2, bird.y + birdSize / 2);
        ctx.rotate(bird.rotation);
        ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.ellipse(-unit*3, flap, unit*2, unit*1.2, -0.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(unit*2.5, flap, unit*2, unit*1.2, 0.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.drawImage(birdImg, -birdSize / 2, -birdSize / 2, birdSize, birdSize);
        if (bird.mouthOpen > 0) {
            ctx.fillStyle = "#660000"; ctx.beginPath();
            ctx.ellipse(unit, unit, unit*1.5, unit*2*(bird.mouthOpen/15), 0, 0, Math.PI*2);
            ctx.fill(); bird.mouthOpen--;
        }
        ctx.restore();
        if (isGameOver) drawDizzyEffect();
    }

    function update() {
        bgX -= (speed * 0.2);
        if (bgX <= -canvas.width) bgX = 0;
        ctx.drawImage(bgImg, bgX, 0, canvas.width, canvas.height);
        ctx.drawImage(bgImg, bgX + canvas.width, 0, canvas.width, canvas.height);

        for (let i = pipes.length - 1; i >= 0; i--) {
            if (gameActive) pipes[i].x -= speed;
            ctx.drawImage(pipeImg, pipes[i].x, 0, pipeWidth, pipes[i].top);
            ctx.save();
            ctx.translate(pipes[i].x + pipeWidth/2, pipes[i].top + pipeGap + (canvas.height - (pipes[i].top + pipeGap))/2);
            ctx.rotate(Math.PI);
            ctx.drawImage(pipeImg, -pipeWidth/2, -(canvas.height - (pipes[i].top + pipeGap))/2, pipeWidth, canvas.height - (pipes[i].top + pipeGap));
            ctx.restore();

            const birdHit = birdSize * 0.2;
            if (gameActive && bird.x + birdHit < pipes[i].x + pipeWidth && bird.x + birdSize - birdHit > pipes[i].x) {
                if (bird.y + birdHit < pipes[i].top || bird.y + birdSize - birdHit > pipes[i].top + pipeGap) {
                    triggerGameOver();
                }
            }
            if (gameActive && !pipes[i].passed && pipes[i].x < bird.x) {
                score++; scoreEl.innerText = score; pipes[i].passed = true;
            }
            if (pipes[i].x < -pipeWidth) pipes.splice(i, 1);
        }

        if (gameActive) {
            bird.velocity += gravity;
            bird.y += bird.velocity;
            if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - (unit * 40)) {
                const top = Math.random() * (canvas.height - pipeGap - unit * 20) + unit * 10;
                pipes.push({ x: canvas.width, top: top, passed: false });
            }
            if (bird.y + birdSize > canvas.height || bird.y < 0) triggerGameOver();
        }

        drawBird();

        if (!gameActive) {
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = `bold ${unit*5}px Arial`;
            ctx.strokeStyle = 'black'; ctx.lineWidth = unit*0.8;
            
            let msg = "";
            if (!isGameOver) {
                msg = "TAP TO START";
            } else {
                if (Date.now() - deathTime < 1500) {
                    msg = "WAIT FOR A MOMENT...";
                } else {
                    msg = "TAP TO START AGAIN";
                }
            }
            
            if (msg !== "") {
                ctx.strokeText(msg, canvas.width / 2, canvas.height / 2);
                ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
            }
        }
        requestAnimationFrame(update);
    }

    function triggerGameOver() {
        if (!isGameOver) {
            gameActive = false; isGameOver = true; 
            deathTime = Date.now(); omgSound.play();
        }
    }

    update();
</script>
</body>
</html>
